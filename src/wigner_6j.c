// wigner_6j
// =========
//
// Evaluate the 6j symbol h(l1) = {l1 l2 l3}
//                                {l4 l5 l6}
// for all allowed values of l1, the other parameters being held fixed.
//
// Origin
// ------
// DRC6J, SLATEC, http://www.netlib.org/slatec.
//
// Keywords
// --------
// 6j coefficients, 6j symbols, Clebsch-Gordan coefficients,
// Racah coefficients, vector addition coefficients, Wigner coefficients
//
// Author
// ------
// Gordon, R. G., Harvard University
// Schulten, K., Max Planck Institute
//
// Usage
// -----
// int wigner_6j(double l2, double l3, double l4, double l5, double l6,
//               double* l1min, double* l1max, double* sixcof, int ndim);
//
// Arguments
// ---------
// l2, l3, l4, l5, l6 : double
//     Parameter in 6j symbol.
// l1min : double*, out
//     Smallest allowable l1 in 6j symbol.
// l1max : double*, out
//     Largest allowable l1 in 6j symbol.
// thrcof : double*, out
//     Set of 6j coefficients generated by evaluating the 6j symbol for all
//     allowed values of l1.  The size of `sixcof` must be at least
//     `l1max-l1min+1` and `sixcof[i]` will contain h(l1min+i), i=0, 1, ...,
//     l1max-l1min.  If `sixcof` is `NULL`, the function will return after
//     `l1min` and `l1max` are set, so that an array of the correct size can
//     be allocated for a subsequent function call.
// ndim : int
//     Declared length of `sixcof` in calling program. If `sixcof` is `NULL`,
//     then `ndim` should be set to 0.
//
// Returns
// -------
// ier : int
//     Error flag.
//     ier=0 No errors.
//     ier=1 Either `l2+l3+l5+l6` or `l4+l2+l6` not an integer.
//     ier=2 `l4`, `l2`, `l6` triangular condition not satisfied.
//     ier=3 `l4`, `l5`, `l3` triangular condition not satisfied.
//     ier=4 `l1max-l1min` not an integer.
//     ier=5 `l1max` less than `l1min`.
//     ier=6 `ndim` less than `l1max-l1min+1`.
//
// Description
// -----------
// The definition and properties of 6j symbols can be found, for
// example, in Appendix C of Volume II of A. Messiah. Although the
// parameters of the vector addition coefficients satisfy certain
// conventional restrictions, the restriction that they be non-negative
// integers or non-negative integers plus 1/2 is not imposed on input
// to this subroutine. The restrictions imposed are
//      1. `l2+l3+l5+l6` and `l2+l4+l6` must be integers;
//      2. `abs(l2-l4) <= `l6` <= `l2+l4` must be satisfied;
//      3. `abs(l4-l5) <= `l3` <= `l4+l5` must be satisfied;
//      4. `l1max-l1min` must be a non-negative integer, where
//         `l1max=min(l2+l3, l5+l6)` and `l1min=max(abs(l2-l3), abs(l5-l6))`.
// If all the conventional restrictions are satisfied, then these
// restrictions are met. Conversely, if input to this subroutine meets
// all of these restrictions and the conventional restriction stated
// above, then all the conventional restrictions are satisfied.
//
// The user should be cautious in using input parameters that do
// not satisfy the conventional restrictions. For example, the
// the subroutine produces values of
//      h(l1) = { l1 2/3  1 }
//              {2/3 2/3 2/3}
// for l1=1/3 and 4/3 but none of the symmetry properties of the 6j
// symbol, set forth on pages 1063 and 1064 of Messiah, is satisfied.
//
// The subroutine generates h(l1min), h(l1min+1), ..., h(l1max)
// where `l1min` and `l1max` are defined above. The sequence h(l1) is
// generated by a three-term recurrence algorithm with scaling to
// control overflow. Both backward and forward recurrence are used to
// maintain numerical stability. The two recurrence sequences are
// matched at an interior point and are normalized from the unitary
// property of 6j coefficients and Wigner's phase convention.
//
// The algorithm is suited to applications in which large quantum
// numbers arise, such as in molecular dynamics.
//
// References
// ----------
// 1. Messiah, Albert., Quantum Mechanics, Volume II, North-Holland
//    Publishing Company, 1963.
// 2. Schulten, Klaus and Gordon, Roy G., Exact recursive evaluation of 3j
//    and 6j coefficients for quantum- mechanical coupling of angular momenta,
//    J Math Phys, v 16, no. 10, October 1975, pp. 1961-1970.
// 3. Schulten, Klaus and Gordon, Roy G., Semiclassical approximations to 3j
//    and 6j coefficients for quantum-mechanical coupling of angular momenta,
//    J Math Phys, v 16, no. 10, October 1975, pp. 1971-1988.
// 4. Schulten, Klaus and Gordon, Roy G., Recursive evaluation of 3j and 6j
//    coefficients, Computer Phys Comm, v 11, 1976, pp. 269-278.
//
// Revision history
// ----------------
// 01 Jan 1975  DATE WRITTEN
// 15 May 1988  SLATEC prologue added by G. C. Nielson, NBS; parameters
//              HUGE and TINY revised to depend on D1MACH.
// 29 Dec 1989  Prologue description rewritten; other prologue sections
//              revised; LMATCH (location of match point for recurrences)
//              removed from argument list; argument IER changed to serve
//              only as an error flag (previously, in cases without error,
//              it returned the number of scalings); number of error codes
//              increased to provide more precise error information;
//              program comments revised; SLATEC error handler calls
//              introduced to enable printing of error messages to meet
//              SLATEC standards. These changes were done by D. W. Lozier,
//              M. A. McClain and J. M. Smith of the National Institute
//              of Standards and Technology, formerly NBS.
// 15 Apr 1991  Mixed type expressions eliminated; variable C1 initialized;
//              description of SIXCOF expanded. These changes were done by
//              D. W. Lozier.
// 22 Jun 2025  Translation to C by N. Tessore.
//

#include <math.h>
#include <float.h>


static inline double phase(int m) {
    return 1 - 2 * (m&1);
}


int wigner_6j(double l2, double l3, double l4, double l5, double l6,
              double* l1min_out, double* l1max_out, double* sixcof, int ndim) {

    // variables
    int i, index, lstep, n, nfin, nfinp1, nfinp2, nfinp3, nlim, nstep2;
    double a1, a1s, a2, a2s, c1, c1old, c2, cnorm, denom, dv, l1, l1min, l1max,
           newfac, oldfac, ratio, sign1, sign2, sum1, sum2, sumbac, sumfor,
           sumuni, thresh, x, x1, x2, x3, y, y1, y2, y3;

    // constants
    const double eps = .01;

    // HUGE is the square root of one twentieth of the largest floating
    // point number, approximately.
    const double huge = sqrt(DBL_MAX/20);
    const double srhuge = sqrt(huge);
    const double tiny = 1.0/huge;
    const double srtiny = 1.0/srhuge;

    // Check error conditions 1, 2, and 3.
    if ((fmod(l2+l3+l5+l6+eps, 1.0) >= eps+eps)
            || (fmod(l4+l2+l6+eps, 1.0) >= eps+eps))
        return 1;
    if ((l4+l2-l6 < 0.0) || (l4-l2+l6 < 0.0) || (-l4+l2+l6 < 0.0))
        return 2;
    if ((l4-l5+l3 < 0.0) || (l4+l5-l3 < 0.0) || (-l4+l5+l3 < 0.0))
        return 3;

    // Limits for l1
    *l1min_out = l1min = fmax(fabs(l2-l3), fabs(l5-l6));
    *l1max_out = l1max = fmin(l2+l3, l5+l6);

    // Check error condition 4.
    if (fmod(l1max-l1min+eps, 1.0) >= eps+eps)
        return 4;

    // Check error condition 5.
    if (l1min >= l1max+eps)
        return 5;

    // Only report l1min and l1max.
    if(!sixcof)
        return 0;

    // Number of coefficients to compute.
    nfin = l1max-l1min+1+eps;

    // Check error condition 6.
    if (ndim < nfin)
        return 6;

    // Check whether l1 can take only one value, ie. l1min = l1max.
    if (l1min >= l1max-eps) {
        sixcof[0] = phase(l2+l3+l5+l6+eps) / sqrt((l1min+l1min+1)*(l4+l4+1));
        return 0;
    }

    // This is reached in case that L1 can take more than one value,
    // i.e. l1min < l1max.

    //  Start of forward recursion
    l1 = l1min;
    newfac = 0.0;
    c1 = 0.0;
    sixcof[0] = srtiny;
    sum1 = (l1+l1+1) * tiny;

    for (lstep = 2;; lstep += 1) {
        l1 = l1 + 1;

        c1old = fabs(c1);
        oldfac = newfac;
        a1 = (l1+l2+l3+1) * (l1-l2+l3) * (l1+l2-l3) * (-l1+l2+l3+1);
        a2 = (l1+l5+l6+1) * (l1-l5+l6) * (l1+l5-l6) * (-l1+l5+l6+1);
        newfac = sqrt(a1*a2);

        // If l1 = 1, (l1 - 1) has to be factored out of dv, hence
        if (l1 < 1+eps) {
            c1 = -2 * (l2*(l2+1) + l5*(l5+1) - l4*(l4+1)) / newfac;
        } else {
            dv = 2 * (
                l2*(l2+1)*l5*(l5+1)
                + l3*(l3+1)*l6*(l6+1)
                - l1*(l1-1)*l4*(l4+1)
            ) - (
                (l2*(l2+1) + l3*(l3+1) - l1*(l1-1))
                * (l5*(l5+1) + l6*(l6+1) - l1*(l1-1))
            );
            denom = (l1-1) * newfac;

            c1 = - (l1+l1-1) * dv / denom;
        }

        // If l1 = l1min + 1, the third term in recursion equation vanishes
        if (lstep == 2) {
              x = srtiny * c1;
              sixcof[1] = x;
              sum1 = sum1 + tiny * (l1+l1+1) * c1 * c1;

              if (lstep == nfin)
                  goto nobac;
        } else {
            c2 = - l1 * oldfac / denom;

            // Recursion to the next 6j coefficient X
            x = c1 * sixcof[lstep-2] + c2 * sixcof[lstep-3];
            sixcof[lstep-1] = x;

            sumfor = sum1;
            sum1 = sum1 + (l1+l1+1) * x * x;
            if (lstep == nfin)
                break;

            // See if last unnormalized 6j coefficient exceeds srhuge
            if (fabs(x) > srhuge) {
                // This is reached if last 6j coefficient larger than srhuge,
                // so that the recursion series sixcof[0], ..., sixcof[lstep-1]
                // has to be rescaled to prevent overflow
                for (i = 0; i < lstep; ++i) {
                    if (fabs(sixcof[i]) < srtiny)
                        sixcof[i] = 0.0;
                    else
                        sixcof[i] = sixcof[i] / srhuge;
                }
                sum1 = sum1 / huge;
                sumfor = sumfor / huge;
                x = x / srhuge;
            }

            // As long as the coefficient abs(c1) is decreasing, the recursion
            // proceeds towards increasing 6j values and, hence, is numerically
            // stable.  Once an increase of abs(c1) is detected, the recursion
            // direction is reversed.
            if (c1old <= fabs(c1))
                break;
        }
    }

    // Keep three 6j coefficients around the match point for comparison later
    // with backward recursion.
    x1 = x;
    x2 = sixcof[lstep-2];
    x3 = sixcof[lstep-3];

    //  Starting backward recursion from l1max taking nstep2 steps, so
    //  that forward and backward recursion overlap at the three points
    //  l1 = lmatch+1, lmatch, lmatch-1.
    nfinp1 = nfin + 1;
    nfinp2 = nfin + 2;
    nstep2 = nfin - lstep + 3;

    sixcof[nfin-1] = srtiny;
    sum2 = (l1max+l1max+1) * tiny;

    l1 = l1max + 2;
    for (lstep = 2;; lstep = lstep + 1) {
        l1 = l1 - 1;

        oldfac = newfac;
        a1s = (l1+l2+l3) * (l1-l2+l3-1) * (l1+l2-l3-1) * (-l1+l2+l3+2);
        a2s = (l1+l5+l6) * (l1-l5+l6-1) * (l1+l5-l6-1) * (-l1+l5+l6+2);
        newfac = sqrt(a1s*a2s);

        dv = 2 * (
            l2*(l2+1)*l5*(l5+1)
            + l3*(l3+1)*l6*(l6+1)
            - l1*(l1-1)*l4*(l4+1)
        ) - (
            (l2*(l2+1) + l3*(l3+1) - l1*(l1-1))
            * (l5*(l5+1) + l6*(l6+1) - l1*(l1-1))
        );

        denom = l1 * newfac;
        c1 = - (l1+l1-1) * dv / denom;

        // If l1 = l1max + 1 the third term in the recursion equation vanishes
        if (lstep == 2) {
            y = srtiny * c1;
            sixcof[nfin-2] = y;
            if (lstep == nstep2)
                break;
            sumbac = sum2;
            sum2 = sum2 + (l1+l1-3) * c1 * c1 * tiny;
        } else {
            c2 = - (l1-1) * oldfac / denom;

            // Recursion to the next 6j coefficient y
            y = c1 * sixcof[nfinp1-lstep] + c2 * sixcof[nfinp2-lstep];
            if (lstep == nstep2)
                break;
            sixcof[nfin-lstep] = y;
            sumbac = sum2;
            sum2 = sum2 + (l1+l1-3) * y * y;

            // See if last unnormalized 6j coefficient exceeds srhuge
            if (fabs(y) > srhuge) {
                // This is reached if last 6j coefficient larger than srhuge,
                // so that the recursion series sixcof[nfin-1], ...,
                // sixcof[nfin-lstep] has to be rescaled to prevent overflow
                for (i = 1; i <= lstep; ++i) {
                    index = nfin - i;
                    if (fabs(sixcof[index]) < srtiny)
                        sixcof[index] = 0.0;
                    else
                        sixcof[index] = sixcof[index] / srhuge;
                }
                sumbac = sumbac / huge;
                sum2 = sum2 / huge;
            }
        }
    }

    // The forward recursion 6j coefficients x1, x2, x3 are to be matched
    // with the corresponding backward recursion values y1, y2, y3.
    y3 = y;
    y2 = sixcof[nfinp1-lstep];
    y1 = sixcof[nfinp2-lstep];

    // Determine now ratio such that yi = ratio * xi  (i=1,2,3) holds
    // with minimal error.
    ratio = (x1*y1 + x2*y2 + x3*y3) / (x1*x1 + x2*x2 + x3*x3);
    nlim = nfin - nstep2 + 1;

    if(fabs(ratio) >= 1.0) {
        for (n = 0; n < nlim; ++n)
            sixcof[n] = ratio * sixcof[n];
        sumuni = ratio * ratio * sumfor + sumbac;
    } else {
        ratio = 1 / ratio;
        for (n = nlim; n < nfin; ++n)
            sixcof[n] = ratio * sixcof[n];
        sumuni = sumfor + ratio*ratio*sumbac;
    }

    goto norm;

nobac:
    sumuni = sum1;

    // Normalize 6j coefficients
norm:
    cnorm = 1 / sqrt((l4+l4+1) * sumuni);

    // Sign convention for last 6j coefficient determines overall phase
    sign1 = copysign(1.0, sixcof[nfin-1]);
    sign2 = phase(l2+l3+l5+l6+eps);
    if (sign1*sign2 <= 0.0)
        cnorm = -cnorm;

    if (fabs(cnorm) >= 1.0) {
        for (n = 0; n < nfin; ++n)
            sixcof[n] = cnorm * sixcof[n];
    } else {
        thresh = tiny / fabs(cnorm);
        for (n = 0; n < nfin; ++n) {
            if (fabs(sixcof[n]) < thresh)
                sixcof[n] = 0.0;
            else
                sixcof[n] = cnorm * sixcof[n];
        }
    }

    return 0;
}
